Information about convertion my own assembly code into 
bunary code for virtual cpu and binary codes for different 
commands for x86 architecture 

//-----------------------------------------------

My registers ==> XMM ( 0 - 15 )

//Push xmm0
sub     rsp, 8
movss  dword [rsp], xmm0

//Pop xmm0
movss  xmm0, dword [rsp]
add     rsp, 8

xmm14, xmm15 for arithm

saving in r13, r14, r15

//-----------------------------------------------

SAVE XMM 0 - 7 : - !!! DIVIDE in SAVE XMM0 and other 

  sub rsp 64
  movss dword [rsp + 0 ], xmm0
  movss dword [rsp + 8 ], xmm1
  movss dword [rsp + 16], xmm2
  movss dword [rsp + 24], xmm3
  movss dword [rsp + 32], xmm4
  movss dword [rsp + 40], xmm5
  movss dword [rsp + 48], xmm6
  movss dword [rsp + 56], xmm7

RESTORE XMM 0 - 7: 

  movss xmm0, dword [rsp + 0 ]
  movss xmm1, dword [rsp + 8 ]
  movss xmm2, dword [rsp + 16]
  movss xmm3, dword [rsp + 24]
  movss xmm4, dword [rsp + 32]
  movss xmm5, dword [rsp + 40]
  movss xmm6, dword [rsp + 48]
  movss xmm7, dword [rsp + 54]

  add rsp, 64

Translating plan:

1) HLT -> Restore_args + Ret

Before : movd r15d, xmm15

2) ADD -> 	
        movss xmm15, dword [rsp + 8]		    
		    addss xmm15, dword [rsp + 0]

        add rsp, 8
		    movss dword [rsp], xmm15

3) SUB -> 	

4) MUL -> 	as ADD 

5) DIV -> 	

after : movd xmm15, r15d

//-----------------------------------------------

6) IN -> 	

      save xmm regs 0-7

			call in functions

      restore xmm regs 0-7

			sub rsp, 8
			movss dword [rsp], xmm0

7) OUT ->  

			movss xmm0, dword [rsp]
			add rsp, 8

			save regs 0-7

			call out function

      restore regs 0-7

8) RET -> 	ret 

9) EQ  -> 	

        movd r15d, xmm0
        movd r14d, xmm1
        movd r13d, xmm13                     

        movss xmm0, dword [rsp + 8]		    
		    subss xmm0, dword [rsp]

		    add rsp, 16
		    	
		    save xmm 1-7
		    call fabs
		    restore xmm 1-7 

		    pxor xmm13, xmm13

		    movss xmm1, [Epsilon]
		    comiss xmm0, xmm1

		    jae .skip
		    movss xmm13, dword [One]

		    .skip:
		    sub rsp, 8
		    movss dword [rsp], xmm13

        movd xmm0,  r15d
        movd xmm1,  r14d
        movd xmm13, r13d

10) MR -> 	

        movd r13d, xmm13
        movd r15d, xmm0

        pxor xmm13, xmm13

			  movss xmm0, dword [rsp]		    
		    comiss xmm0, dword [rsp + 8]

            add rsp, 16

		    jbe .skip
		    movss xmm13, dword [One]

		    .skip:
		    sub rsp, 8
		    movss dword [rsp]. xmm13

        movd xmm13, r13d
        movd xmm0,  r15d


11) JMP -> 

12) JE -> 

13) JNE ->

14) CALL ->

17) SIN -> 

//-----------------------------------------------

My virtual binary code for instructions:

	HLT  - 0 			JMP  - 24
 	ADD  - 1      JA   - 31
 	SUB  - 2 			JAE  - 30
 	MUL  - 3 			JB   - 29
 	DIV  - 4 			JBE  - 28
 	PUSH - 5 			JE   - 27
 	POP  - 6 			JNE  - 26
 	OUT  - 7 			CALL - 25
 	IN   - 8 			
 	RET  - 9 			MASKS:
 	POW  - 10	        
 	EQ   - 11	        Register  - 0x40
 	MR   - 12	        Immediate - 0x20
 	MRE  - 13	        Ram       - 0x80
 	LS   - 14	        
 	LSE  - 15	        OPER_CODE_MASK - ~(7 << 5)
 	NEQ  - 16	        ASCII_offset(for register names) = 96
 	SIN  - 17	        
 	COS  - 18	        
 	TG   - 19	        
 	LN   - 20	        
 	ASIN - 21	     	
 	ATG  - 22	        
 	DRAW - 23	        

    first  = exp
    second = base

    POW -> 

//-----------------------------------------------

First unsigned char in binary - op code
Op_code & OPER_CODE_MASK = one of the codes above

//-----------------------------------------------

Number of registers - 16 
	(luckly just like in real)

//-----------------------------------------------

PUSH and POP has special flags (listed above)

details:

r13d, xmm13 used for push and pop

memory - array of float-point values

1) PUSH: (switch oper_code & ~ OPER_CODE_MASK)	

	- reg + ram

		. get char from binary ( number of register)
		. get value from  memory by index = containment of register
		. push to stack
		. == push [rax]

		// get number of register (for example xmm0)


        cvtss2si r13d, xmm0
		push qword[Start_addr + r13d * 4]


	- reg

		// get number of reg (xmm0 for example)

		sub rsp, 8
		movss dword [rsp], xmm0

	- imm + ram

		. get value from binary (float)
		. push value from memory by index
		. == push word MEMORY_NAME

		// get index in memory array ( for example 1)

    mov r13d, 1
		push qword[Start_addr + r13d * 4]

	- imm

		. get value from binary
		. push immediate to stack
		. == push 1

		// gwt float point value from bianry code
		// patch address of it later

		push qword [Label_for_constant]

	- imm + reg + ram

		. get char from binary = reg number
		. get imm value (float) from binary next
		. push [rax + imm_value]

		// get register number - for example xmm0

    cvtss2si r13d, xmm0

		//store index * 4 in r14d

		push qword[r13d + r14d + Start_addr]

2) POP - popes from stack to different places 

	- reg + ram

		// get reg ( for example xmm0)


    cvtss2si r13d, xmm0
    pop r14
		mov dword [Start_addr + r13d  * 4], r14d
		

	- reg

		// get reg ( for example xmm0)

		movss xmm0, dword[rsp]
		add rsp, 8

	- imm + ram

		// get index in ram
		// store index in r13d

		pop r14
        mov r13d, index
		mov dword [Start_addr + r13d * 4], r14d
	

	- imm

		no such

	- imm + reg + ram

		// get index from binary
		// store it in r15d

		// get reg ( xmm0 for example)

    mov r15d, index * 4
    cvtss2si r13d, xmm0
    pop r14

		movss dword [Start_addr + r13d * 4 + r15d], r14d


//-----------------------------------------------

STACK:

-top-		SUB = second -first
------
first       DIV = second / first
------
second  	
------      POW = second ^ (first)
  ...

//-----------------------------------------------

RET gets float value for binary and jumps by it

//------------------------------------------------

MR == first > second

MRE         >=

LS          <

LSE         <=

NEQ         <>

//------------------------------------------------

All jumps get  dest ip as !!int!! from binary

JA - first > second
JAE        >=

JB         <
JBE        <=

JE         ==
JNE        !=


	



























































































     1                                  ;================================================
     2                                  ;                        (c) Rustam4ik, 2029 - 7
     3                                  ;================================================
     4                                  
     5                                  extern printf 
     6                                  
     7                                  ;================================================
     8                                  
     9                                  section .text 
    10                                  
    11                                  ;====================Macro=======================
    12                                  
    13                                  ;-------------------.EXIT------------------------
    14                                  
    15                                  %macro      .EXIT 0                 
    16                                                                          ; terminates programm
    17                                              xor rdi, rdi                ; exit code 0
    18                                              mov rax, 03Ch               ; exit
    19                                              syscall                 
    20                                  %endmacro
    21                                  
    22                                  ;------------------------------------------------
    23                                  
    24                                  ;================================================
    25                                  
    26                                  section .text 
    27                                  
    28                                  ;==================Main=Body=====================
    29                                  
    30                                  count_quad:
    31 00000000 55                              push    rbp
    32 00000001 4889E5                          mov     rbp, rsp
    33 00000004 F30F1145FC                      movss   DWORD [rbp-4], xmm0
    34 00000009 F30F1045FC                      movss   xmm0, DWORD [rbp-4]
    35 0000000E F30F59C0                        mulss   xmm0, xmm0
    36 00000012 5D                              pop     rbp
    37 00000013 C3                              ret
    38                                  
    39                                  ;==================Main=Body=====================
    40                                  
    41                                  global _start
    42                                  
    43                                  _start:     
    44                                  
    45 00000014 90                      nop
    46 00000015 90                      nop
    47                                  
    48                                  
    49 00000016 67F3440F107C2404                         movss xmm15, dword [rsp + 4]                
    50 0000001E 67F3440F583C24                              addss xmm15, dword [rsp]
    51                                  
    52 00000025 83C404                                      add rsp, 4
    53 00000028 67F3440F113C24                              movss dword [rsp], xmm15
    54                                  
    55 0000002F 90                      nop
    56 00000030 90                      nop
    57                                  
    58 00000031 67F3440F107C2404                       movss xmm15, dword [rsp + 4]                
    59 00000039 67F3440F5C3C24                              subss xmm15, dword [rsp]
    60                                  
    61 00000040 83C404                                      add rsp, 4
    62 00000043 67F3440F113C24                              movss dword [rsp], xmm15
    63                                  
    64 0000004A 90                      nop
    65 0000004B 90                      nop
    66                                  
    67 0000004C 67F3440F107C2404                      movss xmm15, dword [rsp + 4]                
    68 00000054 67F3440F593C24                              mulss xmm15, dword [rsp]
    69                                  
    70 0000005B 83C404                                      add rsp, 4
    71 0000005E 67F3440F113C24                              movss dword [rsp], xmm15
    72                                  
    73 00000065 90                      nop
    74 00000066 90                      nop
    75                                  
    76 00000067 67F3440F107C2404                       movss xmm15, dword [rsp + 4]                
    77 0000006F 67F3440F5E3C24                              divss xmm15, dword [rsp]
    78                                  
    79 00000076 83C404                                      add rsp, 4
    80 00000079 67F3440F113C24                              movss dword [rsp], xmm15
    81                                  
    82                                  
    83 00000080 90                      nop
    84 00000081 90                      nop
    85                                  
    86                                                          ;save regs 
    87                                  
    88                                                          ;call in functions
    89                                  
    90                                                          ;restore regs
    91                                  
    92 00000082 83EC04                                          sub rsp, 4
    93 00000085 67F30F110424                                    movss dword [rsp], xmm0
    94                                  
    95 0000008B 90                      nop
    96 0000008C 90                      nop
    97                                  
    98 0000008D 67F30F110424                                    movss dword [rsp], xmm0
    99 00000093 83C404                                          add rsp, 4
   100                                  
   101                                                          ;save regs
   102                                  
   103                                                          ;call out function
   104                                  
   105                                                          ;restore regs 
   106                                  
   107                                  
   108 00000096 90                      nop
   109 00000097 90                      nop
   110                                  
   111 00000098 67F30F10442404                        movss xmm0, dword [rsp + 4]                 
   112 0000009F 67F30F5C0424                                subss xmm0, dword [rsp]
   113                                  
   114 000000A5 83C408                                      add rsp, 8
   115                                                          
   116                                                      ;save regs 
   117                                                      ;call fabs
   118                                                      ;restore regs 
   119                                  
   120 000000A8 66450FEFED                                  pxor xmm13, xmm13
   121                                  
   122 000000AD F30F100C25-                                 movss xmm1, [Epsilon]
   122 000000B2 [00000000]         
   123 000000B6 0F2FC1                                      comiss xmm0, xmm1
   124                                  
   125 000000B9 730A                                        jae .skip
   126 000000BB F3440F102C25-                               movss xmm13, dword [One]
   126 000000C1 [04000000]         
   127                                  
   128                                                      .skip:
   129 000000C5 83EC04                                      sub rsp, 4
   130 000000C8 67F3440F112C24                              movss dword [rsp], xmm13
   131                                  
   132                                  
   133 000000CF 90                      nop
   134 000000D0 90                      nop
   135                                          
   136 000000D1 66450FEFED                             pxor xmm13, xmm13
   137                                  
   138 000000D6 67F30F100424                            movss xmm0, dword [rsp]             
   139 000000DC 670F2F442404                                comiss xmm0, dword [rsp + 4]
   140                                  
   141 000000E2 760A                                        jbe .skip2
   142 000000E4 F3440F102C25-                               movss xmm13, dword [One]
   142 000000EA [04000000]         
   143                                  
   144                                                      .skip2:
   145 000000EE 83EC04                                      sub rsp, 4
   146 000000F1 67F3440F112C24                              movss dword [rsp], xmm13
   147                                  
   148                                  
   149 000000F8 90                      nop
   150 000000F9 90                      nop
   151                                          .EXIT
   151                              <1> 
   151 000000FA 4831FF              <1>  xor rdi, rdi
   151 000000FD B83C000000          <1>  mov rax, 03Ch
   151 00000102 0F05                <1>  syscall
   152                                  
   153                                  ;================================================
   154                                  
   155                                  section .data 
   156                                  
   157                                  Epsilon:
   158                                  
   159 00000000 3333F33F                        dd 1072902963 
   160                                  
   161                                  One:
   162 00000004 3333F33F                        dd 1072902963
   163                                  
   164                                  LC0:
   165 00000008 3333F33F                        dd   1072902963
   166                                  LC1:
   167 0000000C 33331340                        dd   1075000115
   168                                  
   169 00000010 48656C6C6F20776F72-     FormatStr       db "Hello world ", 0
   169 00000019 6C642000           
   170                                  
   171                                  ;================================================
   172                                  









































DEF_CMD_(0, HLT, 0, 136272956, 
{
    STACK_DESTRUCT(procstruct);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ADD, 1, 4089307820,
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = first_val + second_val;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, SUB, 2, 4160544333,
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = second_val - first_val;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MUL, 3, 4176901080, 
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = second_val * first_val;

    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(0, DIV, 4, 98149758, 
{
    elem_t divider = 0;
    GET_ARGUMENT_FROM_STACK(&divider);

    elem_t dividend = 0;
    GET_ARGUMENT_FROM_STACK(&dividend);

    CHECK_DIVIDER_IS_ZERO(divider);
    
    elem_t result = dividend / divider;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(1, PUSH, 5, 1815514390, 
{
    procstruct->ip++;
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t* value_ptr = get_pointer(procstruct, 
                                    oper_code);

    PUSH_ARGUMENT_TO_STACK(value_ptr);

    procstruct->command_ct++;
})

DEF_CMD_(1, POP, 6, 3218261149, 
{
    procstruct->ip++;
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t* value_ptr = get_pointer(procstruct, 
                                    oper_code);

    GET_ARGUMENT_FROM_STACK(value_ptr);

    procstruct->command_ct++;
})

DEF_CMD_(0, OUT, 7, 1023240496, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_STACK(&value);

    PRINT_PROC_OUTPUT(value);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(0, IN, 8, 955208603, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_PROC_INPUT(&value);

    PUSH_ARGUMENT_TO_STACK(&value);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, RET,  9, 449239908, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_STACK(&value);

    procstruct->command_ct++;
    MOVE_IP_TO_DEST((int)value);
})

DEF_CMD_(0, POW,  10, 3916815338, 
{
    elem_t exp = 0;
    GET_ARGUMENT_FROM_STACK(&exp);

    elem_t base = 0;
    GET_ARGUMENT_FROM_STACK(&base);

    elem_t result = powf(base, exp);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, EQ, 11, 2497190062,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MR, 12, 4260295007,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first > second)
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MRE, 13, 2864530677,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first > second || IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LS, 14, 162631210,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first < second)
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LSE, 15, 273834884,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first < second || IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, NEQ, 16, 3987610013,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (!IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, SIN, 17, 3502304637,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = sin(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, COS, 18, 11133052,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = cos(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, TG, 19, 3508519860,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = tan(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LN, 20, 314398320,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = log(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ASIN, 21, 2062072772,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = asin(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ATG, 22, 2174791585,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = atan(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, DRAW, 23, 316206615,
{
    extern FILE* proc_output;

    for (int vid_print_ct = 1; vid_print_ct <= VIDEO_SIZE; vid_print_ct++)
    {
        fprintf(proc_output, "%c ", (char)(*(procstruct->video + vid_print_ct - 1)));

        if (vid_print_ct % (FRAME_WIDTH) == 0)
            fprintf(proc_output, "\n");
    }

    fflush(proc_output);

    /* for (int vid_print_ct = 1; vid_print_ct <= VIDEO_SIZE; vid_print_ct++)
    {
        printf("videa ram [%d] |%d| |%c|",vid_print_ct + VIDEO_MEMORY_ADDRESS - 1, (char)(*(procstruct->video + vid_print_ct - 1)), (char)(*(procstruct->video + vid_print_ct - 1)));

        if (vid_print_ct % (FRAME_WIDTH) == 0)
            printf("\n");
    } */

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})


DEF_JMP_(1, JMP,  24, 780006197, 
{
    int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    MOVE_IP_TO_DEST(dest_ip);

    procstruct->command_ct++;
})

DEF_JMP_(1, JA,   31, 3413231484, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val > second_val)

        MOVE_IP_TO_DEST(dest_ip)
    
    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++;   
})

DEF_JMP_(1, JAE,  30, 469140019, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val >= second_val) 

        MOVE_IP_TO_DEST(dest_ip)
        
    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JB,   29, 315656441, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val < second_val) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JBE,  28, 3172396438, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val <= second_val) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JE,   27, 1310313540, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (IS_EQUAL(first_val, second_val)) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JNE,  26, 367029121, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (IS_EQUAL(first_val, second_val))

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, CALL, 25, 1316946032, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    procstruct->ip += sizeof(int);
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t return_ip = (elem_t)(procstruct->ip  
                             - procstruct->code_array);

    PUSH_ARGUMENT_TO_STACK(&return_ip);

    MOVE_IP_TO_DEST(dest_ip);

    procstruct->command_ct++;
})