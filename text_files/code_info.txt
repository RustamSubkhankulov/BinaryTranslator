Information about convertion my own assembly code into 
bunary code for virtual cpu and binary codes for different 
commands for x86 architecture 

//-----------------------------------------------

My registers ==> XMM ( 0 - 15 )

//Push xmm0
sub     rsp, 8
movss  dword [rsp], xmm0

//Pop xmm0
movss  xmm0, dword [rsp]
add     rsp, 8

xmm14, xmm15 for arithm

saving in r13, r14, r15

//-----------------------------------------------

SAVE XMM 0 - 7 : - !!! DIVIDE in SAVE XMM0 and other 

  sub rsp 64
  movss dword [rsp + 0 ], xmm0
  movss dword [rsp + 8 ], xmm1
  movss dword [rsp + 16], xmm2
  movss dword [rsp + 24], xmm3
  movss dword [rsp + 32], xmm4
  movss dword [rsp + 40], xmm5
  movss dword [rsp + 48], xmm6
  movss dword [rsp + 56], xmm7

RESTORE XMM 0 - 7: 

  movss xmm0, dword [rsp + 0 ]
  movss xmm1, dword [rsp + 8 ]
  movss xmm2, dword [rsp + 16]
  movss xmm3, dword [rsp + 24]
  movss xmm4, dword [rsp + 32]
  movss xmm5, dword [rsp + 40]
  movss xmm6, dword [rsp + 48]
  movss xmm7, dword [rsp + 54]

  add rsp, 64

Translating plan:

1) HLT -> Restore_args + Ret

Before : movd r15d, xmm15

2) ADD -> 	
        movss xmm15, dword [rsp + 8]		    
		    addss xmm15, dword [rsp + 0]

        add rsp, 8
		    movss dword [rsp], xmm15

3) SUB -> 	

4) MUL -> 	as ADD 

5) DIV -> 	

after : movd xmm15, r15d

//-----------------------------------------------

6) IN -> 	

      save xmm regs 0-7

			call in functions

      restore xmm regs 0-7

			sub rsp, 8
			movss dword [rsp], xmm0

7) OUT ->  

			movss xmm0, dword [rsp]
			add rsp, 8

			save regs 0-7

			call out function

      restore regs 0-7

8) RET -> 	ret 

9) EQ  -> 	

        movd r15d, xmm0
        movd r14d, xmm1
        movd r13d, xmm13                     

        movss xmm0, dword [rsp + 8]		    
		    subss xmm0, dword [rsp]

		    add rsp, 16
		    	
		    save xmm 1-7
		    call fabs
		    restore xmm 1-7 

		    pxor xmm13, xmm13

		    movss xmm1, [Epsilon]
		    comiss xmm0, xmm1

		    jae .skip
		    movss xmm13, dword [One]

		    .skip:
		    sub rsp, 8
		    movss dword [rsp], xmm13

        movd xmm0,  r15d
        movd xmm1,  r14d
        movd xmm13, r13d

10) MR -> 	

        movd r13d, xmm13
        movd r15d, xmm0

        pxor xmm13, xmm13

			  movss xmm0, dword [rsp]		    
		    comiss xmm0, dword [rsp + 8]

            add rsp, 16

		    jbe .skip
		    movss xmm13, dword [One]

		    .skip:
		    sub rsp, 8
		    movss dword [rsp]. xmm13

        movd xmm13, r13d
        movd xmm0,  r15d


11) JMP -> 

12) JE -> 

13) JNE ->

14) CALL ->

17) SIN -> 

//-----------------------------------------------

My virtual binary code for instructions:

	HLT  - 0 			JMP  - 24
 	ADD  - 1      JA   - 31
 	SUB  - 2 			JAE  - 30
 	MUL  - 3 			JB   - 29
 	DIV  - 4 			JBE  - 28
 	PUSH - 5 			JE   - 27
 	POP  - 6 			JNE  - 26
 	OUT  - 7 			CALL - 25
 	IN   - 8 			
 	RET  - 9 			MASKS:
 	POW  - 10	        
 	EQ   - 11	        Register  - 0x40
 	MR   - 12	        Immediate - 0x20
 	MRE  - 13	        Ram       - 0x80
 	LS   - 14	        
 	LSE  - 15	        OPER_CODE_MASK - ~(7 << 5)
 	NEQ  - 16	        ASCII_offset(for register names) = 96
 	SIN  - 17	        
 	COS  - 18	        
 	TG   - 19	        
 	LN   - 20	        
 	ASIN - 21	     	
 	ATG  - 22	        
 	DRAW - 23	        

    first  = exp
    second = base

    POW -> 

//-----------------------------------------------

First unsigned char in binary - op code
Op_code & OPER_CODE_MASK = one of the codes above

//-----------------------------------------------

Number of registers - 16 
	(luckly just like in real)

//-----------------------------------------------

PUSH and POP has special flags (listed above)

details:

r13d, xmm13 used for push and pop

memory - array of float-point values

1) PUSH: (switch oper_code & ~ OPER_CODE_MASK)	

	- reg + ram

		. get char from binary ( number of register)
		. get value from  memory by index = containment of register
		. push to stack
		. == push [rax]

		// get number of register (for example xmm0)


        cvtss2si r13d, xmm0
		push qword[Start_addr + r13d * 4]


	- reg

		// get number of reg (xmm0 for example)

		sub rsp, 8
		movss dword [rsp], xmm0

	- imm + ram

		. get value from binary (float)
		. push value from memory by index
		. == push word MEMORY_NAME

		// get index in memory array ( for example 1)

    mov r13d, 1
		push qword[Start_addr + r13d * 4]

	- imm

		. get value from binary
		. push immediate to stack
		. == push 1

		// gwt float point value from bianry code
		// patch address of it later

		push qword [Label_for_constant]

	- imm + reg + ram

		. get char from binary = reg number
		. get imm value (float) from binary next
		. push [rax + imm_value]

		// get register number - for example xmm0

    cvtss2si r13d, xmm0

		//store index * 4 in r14d

		push qword[r13d + r14d + Start_addr]

2) POP - popes from stack to different places 

	- reg + ram

		// get reg ( for example xmm0)


    cvtss2si r13d, xmm0
    pop r14
		mov dword [Start_addr + r13d  * 4], r14d
		

	- reg

		// get reg ( for example xmm0)

		movss xmm0, dword[rsp]
		add rsp, 8

	- imm + ram

		// get index in ram
		// store index in r13d

		pop r14
        mov r13d, index
		mov dword [Start_addr + r13d * 4], r14d
	

	- imm

		no such

	- imm + reg + ram

		// get index from binary
		// store it in r15d

		// get reg ( xmm0 for example)

    mov r15d, index * 4
    cvtss2si r13d, xmm0
    pop r14

		movss dword [Start_addr + r13d * 4 + r15d], r14d


//-----------------------------------------------

STACK:

-top-		SUB = second -first
------
first       DIV = second / first
------
second  	
------      POW = second ^ (first)
  ...

//-----------------------------------------------

RET gets float value for binary and jumps by it

//------------------------------------------------

MR == first > second

MRE         >=

LS          <

LSE         <=

NEQ         <>

//------------------------------------------------

All jumps get  dest ip as !!int!! from binary

JA - first > second
JAE        >=

JB         <
JBE        <=

JE         ==
JNE        !=


	















# BinaryTranslator
Binary translator from binary code for virtual processor to x86 made as a task at programming course in MIPT DREC 1st grade.

## Formulation of the problem
The task was to write binary translator from architecture of virtual processor, that was made as task too previously, to x86 architecture. Binary translater is made in form of [JIT]( https://en.wikipedia.org/wiki/Just-in-time_compilation "Wikipedia" ) ( Just-in-time ) compiler. By link one can read more about jit compilation.

The main idea of jit compiler - translated code from one another to native code of CPU, executing JIT-compiler, is stored and array and called as function. 

The main result of translating, that we want to achieve, is increasing in performance. Therefore, after talking about translating process, we will test performance and make conclusion.

## My virtual CPU architecture
To be more concise, let's call this architecture r86. 
Firstly, before making plans of translating, necessary step is to examine r86 instructions set and decide which instructions we will translate and which won't be supported by our translator.

| HLT | ADD | SUB | MUL | DIV | PUSH | POP | OUT | IN   | RET | POW  | EQ  | MR   | JA  | JB  | JE  |
|-----|-----|-----|-----|-----|------|-----|-----|------|-----|------|-----|------|-----|-----|-----|
| MRE | LS  | LSE | NEQ | SIN | COS  | TG  | LN  | ASIN | ATG | DRAW | JMP | CALL | JAE | JBE | JNE |

My virtual processor includes array of constant size - RAM, 16 froat registers, each can be used on general purposes.

Instruction set of r86 can be divied in three main parts - arithmetics part, data movement and control instructions ( jumps, call and ret )
My virtual CPU includes stack used for Push-Pop arithmetics. Also return address is stored in stack during call. 

#### Arithmetics

Push-pop arithmetic instructions take two float values from stack, perform calculation and returns result in stack.
Some of arithmetic although need only one argument - SIN, COS etc. These instructions takess only one float value from stack, performes calculation using functions from <math.h> and returns result on the top of the stack. 

Instructions MR, MRE, LS, LSE, EQ and NEQ take two float values from stack, perform comparing and returns bool result of comapring - 0 or 1 - on the top of stack.

#### Control instructions

Call and ret basically work the same as CALL and RET in x86 ( details will be discussed later ). Jumps instructions includes conditionals jumps, that are takes two float values from stack, perform comparing and change current instruction position depending on result of compare. Unlike x86, r86 architecture does not have flags. Also in binary code there are always absolute value of destination of jump, unlike relative version of jumps in x86. 

HLT is necessary instruction at the end of programm. Without is, virtual CPU won't stop executing.

#### Data movement

Two instructions - push and pop - used for data movement. Depending on operation code in binary, different data movement is performed. Unlike x86, in r86 there is no way to move value from one place to another not using stack.
PUSH pushes value to stack from:  1) one of 16 float registers 2) from ram by index containing in register 3) from ram by index containing in binary code 4) from memory by index = immediate value from binary + value in one of 16 registers. Also PUSH can store immediate value from binary code on the top os stack. 
POP performs reverse action, except there is no POP to immediate value.

#### Unsupported instructions

DRAW instruction is used for printing values from special part of RAM - video memory - in terminal. This instruction is too complicated for translating, so this instruction won't be supported in our translator. Actually, this instrucion will be translated to just nothing. So translating will not stop executing, just nothing will be performed. 

## Translating instructions

For translating instructions with float registers in r86, XMM registers are used. If in binary code there are instructions using RAM, float array the same size as RAM in r86 is allocated and used during executing. 

Because of the fact, that XMM registers are used for containing values of registers in r86, regular integer registers of x86 are used for saving value of xmms registers. This will be discussed in details later.

as a stack for arithmetic is used native x86 stack.

Before translated version of instructions, integer registers are saved in stack according to calling convention. Also all XMM registers are set to zeros, because in r86 at the start of programm all of flaot registers are zeros. 

After translated instructions, if there is no HLT in binary code, saved integer registers are poped from stack and RET ( x86 ) exexcuted.

### HLT
Instructions HLT of r86 instruction set is translated into restoring ( poping ) from stack saved integer registers according to calling convention and ret ( x86 instruction )

### Arithmetics

Arithmetics in translated code is also Push-Pop. Before calculating, value of one of XMM registers is saved in integer register, one of the values from stack is moved to this XMM registers. Ther arithmetic instructions is performed, and result is XMM registers. Then RSP is increased by 8 ( poping one of the values from stack ).Then result of calculation is moved from XMM registers back to the stack and value of XMM register is restored.

Note: xmm15 and r15d registers are always used in arithmetics.

Example: ADD

<code>  movd r15d, xmm15                  </code>

<code>  movss xmm15, dword [ rsp + 8 ]    </code>

<code>  adds xmm15,  dword [ rsp ]        </code>

<code>  add rsp, 8                        </code>
  
<code>  movss dword [ rsp ], xmm15        </code>

<code>  movd xmm15, r15d                  </code>

### Data movement - PUSH and POP

##### PUSH

1) PUSH from RAM by index in register:
  Firstly char value is took from binary code - number of register - one of 16. Value in XMM registers is float, so we need to convert it in integer value. Size of float == 4.
  
  <code> cvtss2si r13d, xmm(i) </code>
  
  <code> push qword[ Start_addr + r13d * 4] </code>

2) Push from register:

  <code> sub rsp, 8 </code>
  <code> movss dword [rsp], xmm(i) </code>
  
3) Push from RAM by index equal immediate value from binary code:
  Firstly get flaot value from binary code == index in RAM
  
  <code> mov r13d, index </code>
  
  <code> push qword [ Start_addr + r13d * 4] </code>
  
4) Push immediate value:
  Firstly get float immediate value from binary code, then add this value to specially allocated array of constant values and patch instruction with addres of this patrocular flaot value in array
  
  <code> push qword [Address_of_imm] </code>
  
5) Push from RAM by summ of value in register and immediate value in binary code
  Firstly get char value == number of register, then float value == index in array. This float value is converted into integer value, multiplied by 4 == sizeof(float) and  stored in r14d register. Convert value in xmm(i) registers to integer value in r13d. 

  <code> cvtss2si r13d, xmm(i) </code>
  
  <code> mov r14d, Imm_value_from_binary_code </code>
  
  <code> push qword [ Start_addr + r13d * 4 + r14d ] </code>

##### POP

1) Pop to RAM by index in register:
  Convert float value from xmm register to integer value in r13d, pop from stack to r14, then move value from r14d to RAM

  <code> cvtss2si r13d, xmm(i) </code>
  
  <code> pop r14 </code>
  
  <code> mov dword [ Start_addr + 4 * r13d ], r14d </code>

2) Pop to register:

  <code> movss xmm(i), dword [ rsp ] </code>
  
  <code> add rsp, 8 </code>

3) Pop to RAM by immediate index in bynary code:
  Float value from binary code converted into integer value and stored in r13d
  
  <code> mov r13d, Index_from_binary_code </code>
  
  <code> pop r14 </code>
  
  <code> mov dword [ Start_addr + r13d * 4 ], r14d </code>

4) Pop to RAM by index == summ of immediate value from binary code and value im one of 16 registers:
  Char value from binary == number of register, float value == index 
  
  <code> cvtss2si r13d, xmm(i) </code>
  
  <code> mov r15d, (unsigned int) (float value from binary) * 4 </code>

  <code> pop r14 </code>
  
  <code> mov dword [ Start_addr + r13d * 4 + r15d ], r14d </code>

### Comparing instructions: EQ, NEQ, MR, MRE, LS, LSE

1) Save xmm0, xmm13 values in integer registers:
  
  <code> movd r15d, xmm0  </code>
  <code> movd r13d, xmm13 </code>

2) Null xmm13

  <code> pxor xmm13, xmm13 </code>
 
3) Compare two values on the top of the stack
 
  <code> movss xmm0, dword [ rsp ] </code>
  
  <code> comiss xmm0, dword [ rsp + 8 ] </code>
 
4) Example of translating MR:

  <code> jbe $ + sizeof (next instruction ) </code>

5) Store 1 in xmm13 as result if comapre is true

  <code> movss xmm13, dword [ Address of 1 constant value ] </code>

6) Clear stack from compared values by adding to rsp 16
  
7) Push xmm13 to stack

  <code> sub rsp, 8 </code>
  
  <code> movss dword [ rsp ], xmm13 </code>

8) Restore xmm13 and xmm0 values from integer registers where they were saved.

### Jumps, conditional jumps, call and ret

1) Using system of calculating relative offset from jump to jump destination during translating, all jumps and conditional jumps are translated into near relative versions. Firstly these instructions are initialized in dynamic array of instructions with NULL offset, then during patching offsets are fixed. 
2) Jump, call and ret are translated directly to near relative call and jump and native x86 ret instructions.
3) Conditiolnal jumps in x86 are only short, so conditional jump translated as in example of translating JA (r86):
  
  <code> add rsp, 16 </code>
  
  <code> movd r15d, xmm0 </code>

  <code> movss xmm0, dword [ rsp - 16 ] </code>
  
  <code> comiss xmm0, dword [ rsp - 8 ] </code>

  <code> movd xmm0, r15d </code>

  <code> jbe $ + sizeof (near relative jump) </code>

### Arithmetic instructions - functions and IN/OUT

Input-output instructions and arithmetic functions - POW, SIN, COS, LN and other - are translated to call of needed function in my own standard library.
For each used needed function for <math.h> to calculate value. Firstly only empty call is initialized, but at patching stage of translating addresses are fixed up.
Every call is accompanied by forced pushing and poping using stack all XMM registers, due to the fact, that all XMMs are not preserved during call according to calling convention. 
Also call of calculating functions is accompanied by alignment stack to 16 boundary by calculating remainder of the division RSP by 16 and adding result to RSP ( 8 or 0 if stack is already aligned ). After return alignment, which is saved in one of the preserved during call integer registers, is subtracted from RSP.

##### Example of translating SIN:
  - saving xmm0 value
 
  <code> movd r15d, xmm0 </code>
  
  - pop from stack to xmm0
   
  <code> movss xmm0, dword [ rsp ] </code>
  
  <code> add rsp, 8 </code>
  
  - push XMM registers from 1 to 15
  
  - align stack to 16-boundary
   
  <code> mov r14, rsp </code>
  
  <code> and r14, 0xF </code>
  
  <code> and rsp, r14 </code>
  
  - relative near call, address will be patched later
  call Arithmetic_function
  
  - pop XMM 1 - 15 from stack, restore values
  
  - push XMM0 value to stack 

  <code> sub rsp, 8 </code>
  <code> movss dword [ rsp ], xmm0 </code>
  
  - restore xmm0 value from r15d
  <code> movd xmm0, r15d </code>
  
## Optimization feature

My JIT-compiler includes additional feature, that optimize binary code of r86 architecture before translating. Operations from input are read to list amd then redudant instructions are removed from list. Then remaining instructions are flushed back to buffer, that is used then for translating. 

Optimizations include constant folding in various situations. Examples below:

1) <code> PUSH 0; COS </code>              --> <code> PUSH 1 </code> 
2) <code> PUSH 2; PUSH 3; ADD </code>      --> <code> PUSH 5 </code>
3) <code> PUSH [ax+5]; PUSH 0; MUL </code> --> <code> PUSH 0 </code>
4) <code> PUSH [ax+5]; PUSH 1; MUL </code> --> <code> PUSH [ax+5] </code>
5) <code> PUSH [ax+5]; PUSH 0; ADD </code> --> <code> PUSH [ax+5] </code> 


### Testing optimization increasing in performance. 
To test, how these simple optimization can increase performce, let's run programm, that calculates 2^10 in cycle 10,000,000 times and measure time of JIT-performance.

|           | no opt | -opt flag |
|-----------|--------|-----------|
| time, sec | 0,100  | 0,285     |

We can see increasing in performance by more then 2 times in this simple calculation programm. 

## Comparing performace

Due to the fact, that jit compiler includes executing translating every time it executed, we will test performance using very difficult and big calculations. 
Performance comparing will be between JIT-compiler and compiler for my own language, that was nade as task in previous semester. This compiler output is binary code for my virtual CPU of r86 architecture. The we will also compare results with performce of just only virtual CPU, cause performance of just only CPU is higher then Compiler + CPU. 

As test we will calculate factorial of 34 in cycle 100,000 times. For measuring time linux terminal built-in feature 'time' and save as result 'real' time given by 'time'. Every measurement will be hold several times to decrease random error and as time to compare will be used average of all of the measurements.

Here is [programm](https://github.com/RustamSubkhankulov/BinaryTranslator/blob/main/lang/txt_files/testfactorial.txt "testfactorial.txt") on my own 'harry potter' language, that was used for tests. For testing CPU and JIT generated by my own assembler using this programm r86 binary code was used. 

#### Compiler

| #       | time, sec |
|---------|-----------|
| 1       | 26,082    |
| 2       | 25,231    |
| 3       | 25,321    |
| 4       | 25,355    |
| 5       | 26,784    |
| AVERAGE | 25,7546   |

#### Only CPU

| #       | time, sec |
|---------|-----------|
| 1       | 25,166    |
| 2       | 25,708    |
| 3       | 25,277    |
| 4       | 25,406    |
| 5       | 25,384    |
| AVERAGE | 25,3882   |

#### JIT

| #       | time, sec |
|---------|-----------|
| 1       | 0,1       |
| 2       | 0,133     |
| 3       | 0,096     |
| 4       | 0,105     |
| 5       | 0,098     |
| AVERAGE | 0,1064    |

#### Comparing results and conclusion

|             | Compiler | CPU     | JIT    |
|-------------|----------|---------|--------|
| <time>, sec | 25,7546  | 25,3882 | 0,1064 |
  
As we can see in measured results, difference between compiler and CPU is negligible, calculations takes much more time then syntax and lexic analysis in compiler. Although, difference in performance between JIT and Compiler with CPU is huge. Performing calculation in native commands is increasing performace of programm very effectively. 
  
Total increasing in performace is about 240 times.












































































     1                                  ;================================================
     2                                  ;                        (c) Rustam4ik, 2029 - 7
     3                                  ;================================================
     4                                  
     5                                  extern printf 
     6                                  
     7                                  ;================================================
     8                                  
     9                                  section .text 
    10                                  
    11                                  ;====================Macro=======================
    12                                  
    13                                  ;-------------------.EXIT------------------------
    14                                  
    15                                  %macro      .EXIT 0                 
    16                                                                          ; terminates programm
    17                                              xor rdi, rdi                ; exit code 0
    18                                              mov rax, 03Ch               ; exit
    19                                              syscall                 
    20                                  %endmacro
    21                                  
    22                                  ;------------------------------------------------
    23                                  
    24                                  ;================================================
    25                                  
    26                                  section .text 
    27                                  
    28                                  ;==================Main=Body=====================
    29                                  
    30                                  count_quad:
    31 00000000 55                              push    rbp
    32 00000001 4889E5                          mov     rbp, rsp
    33 00000004 F30F1145FC                      movss   DWORD [rbp-4], xmm0
    34 00000009 F30F1045FC                      movss   xmm0, DWORD [rbp-4]
    35 0000000E F30F59C0                        mulss   xmm0, xmm0
    36 00000012 5D                              pop     rbp
    37 00000013 C3                              ret
    38                                  
    39                                  ;==================Main=Body=====================
    40                                  
    41                                  global _start
    42                                  
    43                                  _start:     
    44                                  
    45 00000014 90                      nop
    46 00000015 90                      nop
    47                                  
    48                                  
    49 00000016 67F3440F107C2404                         movss xmm15, dword [rsp + 4]                
    50 0000001E 67F3440F583C24                              addss xmm15, dword [rsp]
    51                                  
    52 00000025 83C404                                      add rsp, 4
    53 00000028 67F3440F113C24                              movss dword [rsp], xmm15
    54                                  
    55 0000002F 90                      nop
    56 00000030 90                      nop
    57                                  
    58 00000031 67F3440F107C2404                       movss xmm15, dword [rsp + 4]                
    59 00000039 67F3440F5C3C24                              subss xmm15, dword [rsp]
    60                                  
    61 00000040 83C404                                      add rsp, 4
    62 00000043 67F3440F113C24                              movss dword [rsp], xmm15
    63                                  
    64 0000004A 90                      nop
    65 0000004B 90                      nop
    66                                  
    67 0000004C 67F3440F107C2404                      movss xmm15, dword [rsp + 4]                
    68 00000054 67F3440F593C24                              mulss xmm15, dword [rsp]
    69                                  
    70 0000005B 83C404                                      add rsp, 4
    71 0000005E 67F3440F113C24                              movss dword [rsp], xmm15
    72                                  
    73 00000065 90                      nop
    74 00000066 90                      nop
    75                                  
    76 00000067 67F3440F107C2404                       movss xmm15, dword [rsp + 4]                
    77 0000006F 67F3440F5E3C24                              divss xmm15, dword [rsp]
    78                                  
    79 00000076 83C404                                      add rsp, 4
    80 00000079 67F3440F113C24                              movss dword [rsp], xmm15
    81                                  
    82                                  
    83 00000080 90                      nop
    84 00000081 90                      nop
    85                                  
    86                                                          ;save regs 
    87                                  
    88                                                          ;call in functions
    89                                  
    90                                                          ;restore regs
    91                                  
    92 00000082 83EC04                                          sub rsp, 4
    93 00000085 67F30F110424                                    movss dword [rsp], xmm0
    94                                  
    95 0000008B 90                      nop
    96 0000008C 90                      nop
    97                                  
    98 0000008D 67F30F110424                                    movss dword [rsp], xmm0
    99 00000093 83C404                                          add rsp, 4
   100                                  
   101                                                          ;save regs
   102                                  
   103                                                          ;call out function
   104                                  
   105                                                          ;restore regs 
   106                                  
   107                                  
   108 00000096 90                      nop
   109 00000097 90                      nop
   110                                  
   111 00000098 67F30F10442404                        movss xmm0, dword [rsp + 4]                 
   112 0000009F 67F30F5C0424                                subss xmm0, dword [rsp]
   113                                  
   114 000000A5 83C408                                      add rsp, 8
   115                                                          
   116                                                      ;save regs 
   117                                                      ;call fabs
   118                                                      ;restore regs 
   119                                  
   120 000000A8 66450FEFED                                  pxor xmm13, xmm13
   121                                  
   122 000000AD F30F100C25-                                 movss xmm1, [Epsilon]
   122 000000B2 [00000000]         
   123 000000B6 0F2FC1                                      comiss xmm0, xmm1
   124                                  
   125 000000B9 730A                                        jae .skip
   126 000000BB F3440F102C25-                               movss xmm13, dword [One]
   126 000000C1 [04000000]         
   127                                  
   128                                                      .skip:
   129 000000C5 83EC04                                      sub rsp, 4
   130 000000C8 67F3440F112C24                              movss dword [rsp], xmm13
   131                                  
   132                                  
   133 000000CF 90                      nop
   134 000000D0 90                      nop
   135                                          
   136 000000D1 66450FEFED                             pxor xmm13, xmm13
   137                                  
   138 000000D6 67F30F100424                            movss xmm0, dword [rsp]             
   139 000000DC 670F2F442404                                comiss xmm0, dword [rsp + 4]
   140                                  
   141 000000E2 760A                                        jbe .skip2
   142 000000E4 F3440F102C25-                               movss xmm13, dword [One]
   142 000000EA [04000000]         
   143                                  
   144                                                      .skip2:
   145 000000EE 83EC04                                      sub rsp, 4
   146 000000F1 67F3440F112C24                              movss dword [rsp], xmm13
   147                                  
   148                                  
   149 000000F8 90                      nop
   150 000000F9 90                      nop
   151                                          .EXIT
   151                              <1> 
   151 000000FA 4831FF              <1>  xor rdi, rdi
   151 000000FD B83C000000          <1>  mov rax, 03Ch
   151 00000102 0F05                <1>  syscall
   152                                  
   153                                  ;================================================
   154                                  
   155                                  section .data 
   156                                  
   157                                  Epsilon:
   158                                  
   159 00000000 3333F33F                        dd 1072902963 
   160                                  
   161                                  One:
   162 00000004 3333F33F                        dd 1072902963
   163                                  
   164                                  LC0:
   165 00000008 3333F33F                        dd   1072902963
   166                                  LC1:
   167 0000000C 33331340                        dd   1075000115
   168                                  
   169 00000010 48656C6C6F20776F72-     FormatStr       db "Hello world ", 0
   169 00000019 6C642000           
   170                                  
   171                                  ;================================================
   172                                  









































DEF_CMD_(0, HLT, 0, 136272956, 
{
    STACK_DESTRUCT(procstruct);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ADD, 1, 4089307820,
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = first_val + second_val;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, SUB, 2, 4160544333,
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = second_val - first_val;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MUL, 3, 4176901080, 
{
    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    elem_t result = second_val * first_val;

    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(0, DIV, 4, 98149758, 
{
    elem_t divider = 0;
    GET_ARGUMENT_FROM_STACK(&divider);

    elem_t dividend = 0;
    GET_ARGUMENT_FROM_STACK(&dividend);

    CHECK_DIVIDER_IS_ZERO(divider);
    
    elem_t result = dividend / divider;
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;

    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(1, PUSH, 5, 1815514390, 
{
    procstruct->ip++;
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t* value_ptr = get_pointer(procstruct, 
                                    oper_code);

    PUSH_ARGUMENT_TO_STACK(value_ptr);

    procstruct->command_ct++;
})

DEF_CMD_(1, POP, 6, 3218261149, 
{
    procstruct->ip++;
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t* value_ptr = get_pointer(procstruct, 
                                    oper_code);

    GET_ARGUMENT_FROM_STACK(value_ptr);

    procstruct->command_ct++;
})

DEF_CMD_(0, OUT, 7, 1023240496, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_STACK(&value);

    PRINT_PROC_OUTPUT(value);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct); 
})

DEF_CMD_(0, IN, 8, 955208603, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_PROC_INPUT(&value);

    PUSH_ARGUMENT_TO_STACK(&value);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, RET,  9, 449239908, 
{
    elem_t value = 0;
    GET_ARGUMENT_FROM_STACK(&value);

    procstruct->command_ct++;
    MOVE_IP_TO_DEST((int)value);
})

DEF_CMD_(0, POW,  10, 3916815338, 
{
    elem_t exp = 0;
    GET_ARGUMENT_FROM_STACK(&exp);

    elem_t base = 0;
    GET_ARGUMENT_FROM_STACK(&base);

    elem_t result = powf(base, exp);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, EQ, 11, 2497190062,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MR, 12, 4260295007,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first > second)
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, MRE, 13, 2864530677,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first > second || IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LS, 14, 162631210,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first < second)
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LSE, 15, 273834884,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (first < second || IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, NEQ, 16, 3987610013,
{
    elem_t first = 0;
    GET_ARGUMENT_FROM_STACK(&first);

    elem_t second = 0;
    GET_ARGUMENT_FROM_STACK(&second);

    elem_t result = 0;

    if (!IS_EQUAL(first, second))
        result = 1;
    
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, SIN, 17, 3502304637,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = sin(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, COS, 18, 11133052,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = cos(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, TG, 19, 3508519860,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = tan(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, LN, 20, 314398320,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = log(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ASIN, 21, 2062072772,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = asin(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, ATG, 22, 2174791585,
{
    elem_t arg = 0;

    GET_ARGUMENT_FROM_STACK(&arg);

    elem_t result = atan(arg);
    PUSH_ARGUMENT_TO_STACK(&result);

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})

DEF_CMD_(0, DRAW, 23, 316206615,
{
    extern FILE* proc_output;

    for (int vid_print_ct = 1; vid_print_ct <= VIDEO_SIZE; vid_print_ct++)
    {
        fprintf(proc_output, "%c ", (char)(*(procstruct->video + vid_print_ct - 1)));

        if (vid_print_ct % (FRAME_WIDTH) == 0)
            fprintf(proc_output, "\n");
    }

    fflush(proc_output);

    /* for (int vid_print_ct = 1; vid_print_ct <= VIDEO_SIZE; vid_print_ct++)
    {
        printf("videa ram [%d] |%d| |%c|",vid_print_ct + VIDEO_MEMORY_ADDRESS - 1, (char)(*(procstruct->video + vid_print_ct - 1)), (char)(*(procstruct->video + vid_print_ct - 1)));

        if (vid_print_ct % (FRAME_WIDTH) == 0)
            printf("\n");
    } */

    procstruct->command_ct++;
    MOVE_IP_TO_NEXT_COMMAND(procstruct);
})


DEF_JMP_(1, JMP,  24, 780006197, 
{
    int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    MOVE_IP_TO_DEST(dest_ip);

    procstruct->command_ct++;
})

DEF_JMP_(1, JA,   31, 3413231484, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val > second_val)

        MOVE_IP_TO_DEST(dest_ip)
    
    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++;   
})

DEF_JMP_(1, JAE,  30, 469140019, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val >= second_val) 

        MOVE_IP_TO_DEST(dest_ip)
        
    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JB,   29, 315656441, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val < second_val) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JBE,  28, 3172396438, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (first_val <= second_val) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JE,   27, 1310313540, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (IS_EQUAL(first_val, second_val)) 

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, JNE,  26, 367029121, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    elem_t first_val = 0;
    GET_ARGUMENT_FROM_STACK(&first_val);

    elem_t second_val = 0;
    GET_ARGUMENT_FROM_STACK(&second_val);

    if (IS_EQUAL(first_val, second_val))

        MOVE_IP_TO_DEST(dest_ip)

    else {
        procstruct->ip += sizeof(int);
        PROCSTRUCT_IP_CHECK(procstruct);
    }

    procstruct->command_ct++; 
})

DEF_JMP_(1, CALL, 25, 1316946032, 
{
     int dest_ip = 0;
    GET_DESTINATION_IP(&dest_ip);

    procstruct->ip += sizeof(int);
    PROCSTRUCT_IP_CHECK(procstruct);

    elem_t return_ip = (elem_t)(procstruct->ip  
                             - procstruct->code_array);

    PUSH_ARGUMENT_TO_STACK(&return_ip);

    MOVE_IP_TO_DEST(dest_ip);

    procstruct->command_ct++;
})